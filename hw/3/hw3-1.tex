\documentclass[11pt]{amsart}
\usepackage{amsmath,amsthm,amssymb,amsfonts,epic,epsfig,latexsym,enumerate}
\usepackage{enumitem}
\usepackage[titlenotnumbered,linesnumbered,noend,plain]{algorithm2e}
\usepackage{listings}
\usepackage{fullpage}

\newtheorem{lemma}{Lemma}
\usepackage{url}

%\SetKwProg{Fn}{}{}{}

\setlength{\parindent}{0pt}
\thispagestyle{empty}

\setlength{\textwidth} {465pt}
\setlength{\textheight} {700pt}
\setlength{\oddsidemargin} {0pt}
\setlength{\evensidemargin} {0pt}

\setlength{\topmargin}{0pt}
\setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}
\setlength{\footskip}{0pt}

\setlength{\marginparwidth} {1in}



\begin{document}



%\thispagestyle{empty}

%\hspace{0.11cm} \vspace{2cm}

\title{
Com S 311 Spring 2021\\
Homework 3
}

\maketitle


\vspace{-.8cm}
\begin{center}
{\bf Due:  April 2, 11:59 p.m.}

\smallskip
\textbf{Early submission: April 1, 11:59 p.m., (5\% bonus)}

\smallskip
{\bf Late Submission Due: April 3, 11:59 \textbf{A.M.} (25\% penalty)\\
(submissions after this deadline will not be graded)}
\textbf{\\Haadi-Mohammad Majeed\\Collaborated with Nathan Tucker and Matthew Hoskins} 
\end{center}

\medskip

\section*{\large Guidelines}


\begin{itemize}

\item %It is important to know whether you really know. 
For each problem, if you write  the statement ``I do not know how to solve this problem'' (and nothing else), you will receive 20\% credit for that problem. If you do write a solution, then your grade could be anywhere between 0\% to 100\%.
To receive this 20\% credit, you must explicitly state that you do not know how to solve the problem.

\item You are allowed to discuss with classmates, but you must work on the homework problems on your own.  You should write the final solutions alone, without consulting anyone. Your writing should demonstrate that you understand the proofs completely.

\item When proofs are required, you should make them both clear and rigorous. Do not hand-waive.

 \item Please submit your assignment via Canvas.
 \begin{itemize}
\item  You \textbf{must} type your solutions. Please submit a PDF version.
\item Please make sure that the file you submit is not corrupted and that its size is reasonable (e.g., roughly at most 10-11 MB).
\begin{center}
\emph{If we cannot open your file, your homework will not be graded.}
\end{center}
\end{itemize}

\item Any concerns about grading should be expressed within one week of
returning the homework. 
 
\end{itemize}


\section*{\large Problems}


(1) The Elevator Problem\medskip

At a prestigious computer science department, there is an elevator that is serving $n$ floors. The elevator has 
$k$ buttons, each annotated by an integer that, when pressed, travels the integer number of floors. Note that 
when pressing a button that would move to a floor not served by the elevator, the elevator will not move.\medskip

For example, the elevator could serve 72 floors and have buttons annotated with integers -5 and 2. If the elevator is on
floor 17 and pressing the button with integer -5 will move the elevator to floor 12. Then pressing two times the button with
integer 2 will move the elevator to level 16.\medskip

It is a high sport culture for the inhabitants of this building to find out if it is possible to travel with the elevator from floor
$i$ to floor $j$ by pressing a sequence of buttons. If so, then the inhabitants want to know a shortest such sequence
and how many shortest sequences there are.\medskip

Write an efficient dynamic programming algorithm in pseudo-code that answers these questions, give a brief justification
of its correctness, and analyze its runtime.\\

The input parameters for your algorithm should include (i) $n\in \mathbb{N}$ representing the number of floors the 
elevator is serving, (ii) $b_1,\ldots, b_k \in \mathbb{Z}$ ($k\in\mathbb{N}$) representing the buttons with their
integer values, and (iii) $i,j \in \{1,\ldots , n\}$ where we want to know whether the elevator can travel from floor $i$ to floor $j$.
As output, the algorithm should state "NO" when moving from floor $i$ to floor $j$ is not possible. Otherwise, the 
algorithm should output (i) a shortest sequence of integers describing the buttons pressed to move the elevator from floor
$i$ to floor $j$, and (ii) the number of such sequences.

\newpage
\begin{lstlisting}
floorSeq(int i, int j, int n, int b[]){
    count = 0
    arr[] = empty arr
    if(i == j) 
        return count, arr
    return recur(i, j, n, b, count, arr)
}

recur(int i, int j, int n, int b[], int count, int arr[]){
    if(i == j) 
        return ++count, arr
    out = "no"
    if(floor.visited(i) || i > n || i < 1) 
        return out
    else 
        floor.add(i) //a set of all floors visited
    for(k->b.length)
        out = recur(i+b[k], j, n, b, count, arr + b[k]) 
        //increment i for the next call, and add the 
        //element in b[k] to the end of arr
    return out    
}
\end{lstlisting}
This follows a bottom up approach fro every possible floor N, with every possible button B given to the method. Subsequently this results in a runtime of O(N*B) as it hits every B values N times to determine the route
\newpage

(2) The Cookie Game\medskip

Riley and Morgan play the following cookie game. Given is one set of $n$ red cookies and another set of $m$ green 
cookies. At every turn, a player must eat two cookies from one set and one cookie from the other set (i.e., 
either (i) two green cookies and one red cookie, or (ii) two red cookies and one green cookie). The player who 
cannot move loses. Assuming Riley will begin the game, which player will win?\medskip

Write an efficient dynamic programming algorithm in pseudo-code that decides whether a winning strategy for one of the players exists,
give a brief justification of the correctness of your algorithm, and analyze its runtime.\medskip

Your algorithm's input parameters should include $n, m \in \mathbb{N}_0$ representing the given numbers of green 
and red cookies, respectively. As output, the algorithm should state whether Riley or Morgan will win, or if there is no
winning strategy for either player.\\
\begin{lstlisting}
cookie(int n, int m){
    Let arr[1->m][1->n] 2d array
    for(i->m)
        for(j->n)
            arr[m][n] = CalculateDepth(i,j) 
            //This is a O(1) runtime helper method that returns the 
            //depth at the location, otherwise a -1
    if(arr[m][n] == -1) return "No Winner"
    if(arr[m][n] is even) return "Morgan Wins"
    return "Riley Wins"
}
\end{lstlisting}
Bottom up approach\\
0$\rightarrow m$\\
0$\rightarrow n$
\\
Store depth of moves in the index of a 2d matrix
\\
Example
3 of m, 3 of n would be 2 moves from a win
How far from last move - depth is distance from win
\\
Index $3, 3 \rightarrow 2$ moves remaining
Last index of [m][n] if even, A wins, if odd, B wins
\\
Set [index] to -1 b/c if at the end and the index is -1, there is no winning strat
Runtime of O(m*n)
it has such a run time since it iterates through the for loops n times m times, resulting in m*n, with every other line being a constant runtime of O(1). Inside the second for loop a helper method is called to assist in determining the depth from the win, yet it will return -1 if the game is determined to be unwinnable from either party. This method runs in O(1) which also assists in the overall runtime being O(M*N)
\newpage
(3) The Constrained LCS Problem\medskip

Let $X$ and $Y$ be strings over an alphabet $\Sigma$. For $\Gamma\subseteq \Sigma$ we define the \emph{$\Gamma$-constrained longest common subsequence } of $X$ and $Y$ to be a longest common subsequence of $X$ and $Y$ that does NOT 
contain any of the characters in $\Gamma$.\medskip

Give a detailed proof that the problem of finding a constrained longest common subsequence exhibits optimal substructure.\\\\
1) $x_m = y_n \rightarrow$ then $\Gamma_k = x_m = y_n$ and $\Gamma_{k-1}$ is a constrained Longest Common Subsequence of $x_{m-1} = y_{n-1}$
\\
2) $x_m \neq y_n \rightarrow$ then $\Gamma_k \neq x_m$ and implies that $\Gamma$ is a constrained Longest Common Subsequence of $x_{m-1} = y$
\\
3) $x_m \neq y_n \rightarrow$ then $\Gamma_k \neq y_n$ and implies that $\Gamma$ is a constrained Longest Common Subsequence of $x_m = y_{n-1}$
\\\\
1)
Contradiction\\
Establishing that $\Gamma \neq X_M$, add $x_m = y_n$ to $\Gamma$ and a constrained LCS if X and Y is formed with a length of $\Gamma$'s k + 1. This counters the theory that $\Gamma$ of size k is the LCS and must therefore have to be $\Gamma_k = x_m = y_n$\\ABCD, as an example, is the Constrained LCS of $x_{m-1} = y_{n-1}$ with n and m $>$ k-1. The current $\Gamma$ now produces a common subsequence of x and y, but yields a length greater than k which now contradicts the theory(1).
\\\\
2)
Contradiction\\
ABCD is once again the constrained LCS but now for $x_{m-1} = y$ with the new CS lengths being greater than K, it is once again contradicts the inital theory(2).
\\\\
3)
Contradiction\\
if $x_m \neq y_n$ then contradiciton would allow for ABCD to be the constrained LCS of $x = y_{n-1}$ with length greater than k. This follows similar logic to (2)
\\\\
Optimial substructure is shown here as the inital problem has been broken up into multiple parts and then solving them indivudally. 
\newpage
(4) Minimum Spanning Trees\medskip

Let $G=(V,E)$ be a connected and undirected graph with a weight function $c\colon E \to \mathbb{R}$. \medskip

Given an arbitrary vertex $v\in V$, is it true that an edge incident to $v$ with the least weight always belongs to some minimum spanning tree of $G$?\medskip

Give a thorough proof showing the correctness of your answer. 
\\\\\\
Graph theory states that a vertex is incident to the edge of the vertex if one of the two verticies the edge connects. An incidence is a pair where it is a vertex and in an edge incident. Two edges are labeled as incident if they have a common vertex.\\Proof via Contradiction\\Edge V connected to least weighted [w] edge dictated by (u,v)\\Assuming (u,v) does not belong to a min weight spanning tree, there is a solution from u and v that does not utilise this edge. With this new edge, the highest valued, edge should be removed and the new edge and node attatched. Due to the connectivity property, the tree should be reformed with a new path. therefore re-establishing a minimum spanning tree. \\The weight of the tree can be calculated with \\
weight of original tree - (weight of original tree - weight of removed edge - weight of new edge)\\
This result cannot be negative since the new branch should be lighter than the removed one. $\therefore$ the new tree weighs less than the original. This proves that given an arbitraty vertex v $\epsilon $ V is incident with (u,v) with graph G.


\end{document}